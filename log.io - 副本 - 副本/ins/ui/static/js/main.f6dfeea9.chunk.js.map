{"version":3,"sources":["reducers/bindings/types.ts","reducers/inputs/types.ts","reducers/screens/types.ts","components/app/initialize.ts","contexts.ts","components/inputs/util.ts","components/inputs/controls.tsx","components/inputs/index.tsx","reducers/bindings/index.ts","reducers/inputs/index.ts","reducers/messages/types.ts","reducers/messages/index.ts","socket/index.ts","middleware/socket.ts","middleware/url.ts","reducers/screens/index.ts","reducers/index.ts","components/screens/index.tsx","components/app/index.tsx","index.tsx"],"names":["BindingActions","InputActions","ScreenActions","initializeState","dispatch","locationHash","screens","JSON","parse","decodeURI","slice","e","console","warn","type","Object","keys","forEach","screenId","inputName","split","stream","source","DispatchContext","createContext","StateContext","getDiodeClass","lastPing","timeDiff","Date","getTime","activeNum","Math","floor","MappedInputControls","input","labelName","state","bindings","isBound","useMemo","inputs","toggleInputBinding","name","diodeClass","ping","className","map","i","key","title","data-testid","checked","onChange","InputControls","ConnectedInputControls","useContext","InputGroups","filter","groupType","inputState","toggleBinding","groups","displayGroups","groupName","group","trim","toLowerCase","includes","pairs","otherName","MappedInputManager","useState","activeInputGroup","setActiveInputGroup","activeFilter","setActiveFilter","onClick","value","target","placeholder","InputManager","ConnectedInputManager","initialBindingState","sources","streams","bindInputToScreen","unbindInputFromScreen","checkStreamBinding","every","checkSourceBinding","BindingReducer","produce","action","screenBindings","initialInputState","InputReducer","pingTime","MessageActions","initialMessageState","MessageReducer","msg","updatedScreens","message","updatedMessages","concat","length","MAX_MESSAGES","sendBindInput","socket","emit","sendUnbindInput","socketMiddleware","some","urlMiddleware","urlBindingState","window","location","hash","stringify","initialScreenState","ScreenReducer","String","valueOf","id","messages","Reducer","newState","ScreenMessage","messageFilter","str","find","parts","counter","lastMatchIndex","lowerStr","lowerFind","end","substring","push","highlight","text","_parseMessageParts","part","Screen","clearMessages","removeScreen","screen","screenIndex","setMessageFilter","validMessages","setValidMessages","useEffect","minLength","debounceTimeout","MappedScreenManager","addScreen","screenIds","ScreenManager","ConnectedScreenManager","App","initialState","useReducer","reducer","on","registerNewInput","registerRemoveInput","registerPing","data","registerNewMessage","Provider","ReactDOM","render","socketIO","document","getElementById"],"mappings":"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","file":"static/js/main.f6dfeea9.chunk.js","sourcesContent":["import { ScreenActionTypes } from '../screens/types'\nimport { EnsureInputAction } from '../inputs/types'\n\nexport const BindingActions = {\n  BIND_INPUT_TO_SCREEN: 'BIND_INPUT_TO_SCREEN' as 'BIND_INPUT_TO_SCREEN',\n  BIND_SOURCE_TO_SCREEN: 'BIND_SOURCE_TO_SCREEN' as 'BIND_SOURCE_TO_SCREEN',\n  BIND_STREAM_TO_SCREEN: 'BIND_STREAM_TO_SCREEN' as 'BIND_STREAM_TO_SCREEN',\n  UNBIND_INPUT_FROM_SCREEN: 'UNBIND_INPUT_FROM_SCREEN' as 'UNBIND_INPUT_FROM_SCREEN',\n  UNBIND_SOURCE_FROM_SCREEN: 'UNBIND_SOURCE_FROM_SCREEN' as 'UNBIND_SOURCE_FROM_SCREEN',\n  UNBIND_STREAM_FROM_SCREEN: 'UNBIND_STREAM_FROM_SCREEN' as 'UNBIND_STREAM_FROM_SCREEN',\n}\n\nexport type BindingState = {\n  inputs: { [inputName: string]: { [screenId: string]: boolean } },\n  screens: {\n    [screenId: string]: {\n      inputs: { [inputName: string]: boolean },\n      streams: { [streamName: string ]: boolean },\n      sources: { [sourceName: string ]: boolean },\n    },\n  },\n  sources: { [sourceName: string]: { [screenId: string]: boolean } },\n  streams: { [streamName: string]: { [screenId: string]: boolean } },\n\n}\n\nexport type BindInputToScreenAction = {\n  type: typeof BindingActions.BIND_INPUT_TO_SCREEN,\n  inputName: string,\n  stream: string,\n  source: string,\n  screenId: string,\n}\n\nexport type UnbindInputFromScreenAction = {\n  type: typeof BindingActions.UNBIND_INPUT_FROM_SCREEN,\n  inputName: string,\n  stream: string,\n  source: string,\n  screenId: string,\n}\n\nexport type BindSourceToScreenAction = {\n  type: typeof BindingActions.BIND_SOURCE_TO_SCREEN,\n  source: string,\n  screenId: string,\n}\n\nexport type UnbindSourceFromScreenAction = {\n  type: typeof BindingActions.UNBIND_SOURCE_FROM_SCREEN,\n  source: string,\n  screenId: string,\n}\n\nexport type BindStreamToScreenAction = {\n  type: typeof BindingActions.BIND_STREAM_TO_SCREEN,\n  stream: string,\n  screenId: string,\n}\n\nexport type UnbindStreamFromScreenAction = {\n  type: typeof BindingActions.UNBIND_STREAM_FROM_SCREEN,\n  stream: string,\n  screenId: string,\n}\n\nexport type BindingActionTypes = BindInputToScreenAction\n  | BindSourceToScreenAction\n  | BindStreamToScreenAction\n  | UnbindInputFromScreenAction\n  | UnbindSourceFromScreenAction\n  | UnbindStreamFromScreenAction\n  | ScreenActionTypes\n  | EnsureInputAction","export const InputActions = {\n  ENSURE_INPUT: 'ENSURE_INPUT' as 'ENSURE_INPUT',\n  PING: 'PING' as 'PING',\n  REMOVE_INPUT: 'REMOVE_INPUT' as 'REMOVE_INPUT',\n}\n\nexport type Input = {\n  name: string,\n  stream: string,\n  source: string,\n  ping: number | null,\n}\n\nexport type Pairs = {\n  pairs: { [sourceName: string]: string },\n  ping: number | null,\n}\n\nexport type InputState = {\n  inputs: { [inputName: string]: Input },\n  streams: { [streamName: string]: Pairs },\n  sources: { [sourceName: string]: Pairs },\n}\n\nexport type EnsureInputAction = {\n  type: typeof InputActions.ENSURE_INPUT,\n  inputName: string,\n  stream: string,\n  source: string,\n}\n\nexport type RemoveInputAction = {\n  type: typeof InputActions.REMOVE_INPUT,\n  inputName: string,\n  stream: string,\n  source: string,\n}\n\nexport type PingAction = {\n  type: typeof InputActions.PING,\n  inputName: string,\n  stream: string,\n  source: string,\n}\n\nexport type InputActionTypes = EnsureInputAction | PingAction | RemoveInputAction\n","export const ScreenActions = {\n  ADD_SCREEN: 'ADD_SCREEN' as 'ADD_SCREEN',\n  REMOVE_SCREEN: 'REMOVE_SCREEN' as 'REMOVE_SCREEN',\n}\n\nexport type Screen = {\n  id: string,\n  messages: Array<string>,\n}\n\nexport type ScreenState = {\n  screens: { [screenId: string]: Screen },\n}\n\nexport type AddScreenAction = {\n  type: typeof ScreenActions.ADD_SCREEN,\n  screenId?: string,\n}\n\nexport type RemoveScreenAction = {\n  type: typeof ScreenActions.REMOVE_SCREEN,\n  screenId: string,\n}\n\nexport type ScreenActionTypes = AddScreenAction | RemoveScreenAction\n","import { Dispatch } from 'react'\nimport { UrlBindingStateType } from '../../middleware/url'\nimport { BindingActions } from '../../reducers/bindings/types'\nimport { InputActions } from '../../reducers/inputs/types'\nimport { ScreenActions } from '../../reducers/screens/types'\nimport { ActionTypes } from '../../reducers/types'\n\n/**\n * Initializes screen state & any saved input bindings.\n * Parses saved state from URL location hash\n */\nconst initializeState = (\n  dispatch: Dispatch<ActionTypes>,\n  locationHash: string\n) => {\n  if (locationHash === '' || locationHash === '#') {\n    dispatch({ type: ScreenActions.ADD_SCREEN })\n    return\n  }\n  // Parse screen state from URL hash\n  let screens: UrlBindingStateType = {}\n  try {\n    screens = JSON.parse(decodeURI(locationHash.slice(1)))\n  } catch (e) {\n    console.warn(\"Unable to parse previous screen state:\", locationHash)\n    dispatch({ type: ScreenActions.ADD_SCREEN })\n    return\n  }\n  // Trigger redux actions to initialize screens, inputs, and bindings\n  Object.keys(screens).forEach((screenId) => {\n    dispatch({\n      type: ScreenActions.ADD_SCREEN,\n      screenId,\n    })\n    screens[screenId].forEach((inputName) => {\n      const [stream, source] = inputName.split('|')\n      dispatch({\n        type: InputActions.ENSURE_INPUT,\n        inputName,\n        stream,\n        source,\n      })\n      dispatch({\n        type: BindingActions.BIND_INPUT_TO_SCREEN,\n        inputName,\n        stream,\n        source,\n        screenId,\n      })\n    })\n  })\n}\n\nexport default initializeState","import { createContext, Dispatch } from 'react'\nimport { State, ActionTypes } from './reducers/types'\n\nexport const DispatchContext = createContext<Dispatch<ActionTypes> | null>(null)\nexport const StateContext = createContext<State | null>(null)\n","/**\n * Return diode CSS class name based on recency of input ping time\n */\nexport const getDiodeClass = (lastPing: number | null): string => {\n  if (!lastPing) {\n    return 'nosignal'\n  }\n  const timeDiff = new Date().getTime() - lastPing\n  if (timeDiff < 10000) {\n    const activeNum = Math.floor(timeDiff / 1000)\n    return `active${activeNum}`\n  }\n  return 'inactive'\n}\n","import React, { Dispatch, useContext, useMemo } from 'react'\nimport { DispatchContext } from '../../contexts'\nimport { BindingActions } from '../../reducers/bindings/types'\nimport { ScreenState } from '../../reducers/screens/types'\nimport { StateContext } from '../../contexts'\nimport { State } from '../../reducers/types'\nimport { Input } from '../../reducers/inputs/types'\nimport { ActionTypes } from '../../reducers/types'\nimport { getDiodeClass } from './util'\n\nimport './styles.scss'\n\ntype GroupTypes = 'streams' | 'sources'\n\ninterface InputControlsProps {\n  input: Input,\n  isBound: (inputName: string, screenId: string) => boolean,\n  labelName: string,\n  screens: ScreenState,\n  toggleInputBinding: (\n    inputName: string,\n    stream: string,\n    source: string,\n    screenId: string\n  ) => void,\n}\n\ninterface MappedInputControls {\n  dispatch: Dispatch<ActionTypes>,\n  input: Input,\n  labelName: string,\n  state: State,\n}\n\ninterface ConnectedInputControlsProps {\n  input: Input,\n  labelName: string,\n}\n\n/**\n * Show a single input and its corresponding screen binding controls\n */\nconst InputControls: React.FC<InputControlsProps> = ({\n  input,\n  isBound,\n  labelName,\n  screens,\n  toggleInputBinding,\n}) => {\n  const inputName = input.name\n  const diodeClass = getDiodeClass(input.ping)\n  return (\n    <div className=\"input\">\n      <div className={`diode ${diodeClass}`}/>\n      <label>{labelName}</label>\n      {Object.keys(screens.screens).map((screenId, i) => (\n        <input\n          key={screenId}\n          title={`Screen ${i + 1}`}\n          data-testid={`input-control-${inputName}:${i}`}\n          type=\"checkbox\"\n          checked={isBound(inputName, screenId)}\n          onChange={() => toggleInputBinding(\n            inputName,\n            input.stream,\n            input.source,\n            screenId\n          )}\n        />\n      ))}\n    </div>\n  )\n}\n\n/**\n * Creates handler functions from app state\n */\nconst MappedInputControls: React.FC<MappedInputControls> = ({\n  dispatch,\n  input,\n  labelName,\n  state\n}) => {\n  const { bindings, screens } = state\n\n  // Create helper function to determine if input is bound\n  const isBound = useMemo(() => (\n    (inputName: string, screenId: string): boolean => (\n      !!bindings.inputs[inputName] && !!bindings.inputs[inputName][screenId]\n    )\n  ), [bindings])\n\n  // Create function to update app state & notify server on input binding change\n  const toggleInputBinding = useMemo(() => (\n    (inputName: string, stream: string, source: string, screenId: string): void => {\n      if (isBound(inputName, screenId)) {\n        dispatch({\n          type: BindingActions.UNBIND_INPUT_FROM_SCREEN,\n          inputName,\n          stream,\n          source,\n          screenId\n        })\n      } else {\n        dispatch({\n          type: BindingActions.BIND_INPUT_TO_SCREEN,\n          inputName,\n          stream,\n          source,\n          screenId\n        })\n      }\n    }\n  ), [dispatch, isBound])\n\n  return InputControls({ input, isBound, labelName, screens, toggleInputBinding })\n}\n\n\n/**\n * Connects component to app contexts\n */\nconst ConnectedInputControls: React.FC<ConnectedInputControlsProps> = ({ input, labelName }) => {\n  const dispatch: Dispatch<ActionTypes> | null = useContext(DispatchContext)\n  const state: State | null = useContext(StateContext)\n  if (!dispatch || !state) {\n    return null\n  }\n  return MappedInputControls({ dispatch, input, labelName, state })\n}\n\nexport default ConnectedInputControls\n","import React, { Dispatch, useContext, useMemo, useState } from 'react'\nimport InputControls from './controls'\nimport { DispatchContext, StateContext } from '../../contexts'\nimport { BindingActions } from '../../reducers/bindings/types'\nimport { InputState } from '../../reducers/inputs/types'\nimport { ScreenState } from '../../reducers/screens/types'\nimport { ActionTypes, State } from '../../reducers/types'\n\nimport { getDiodeClass } from './util'\nimport './styles.scss'\n\ntype GroupTypes = 'streams' | 'sources'\n\ninterface InputGroupsProps {\n  filter: string,\n  groupType: GroupTypes,\n  inputState: InputState,\n  isBound: (groupType: GroupTypes, groupName: string, screenId: string) => boolean,\n  screens: ScreenState,\n  toggleBinding: (groupType: GroupTypes, groupName: string, screenId: string) => void,\n}\n\ninterface InputManagerProps {\n  inputs: InputState,\n  isBound: (groupType: GroupTypes, groupName: string, screenId: string) => boolean,\n  screens: ScreenState,\n  toggleBinding: (groupType: GroupTypes, groupName: string, screenId: string) => void,\n}\n\ninterface MappedInputManagerProps {\n  dispatch: Dispatch<ActionTypes>,\n  state: State,\n}\n\nconst InputGroups: React.FC<InputGroupsProps> = ({\n  filter,\n  groupType,\n  inputState,\n  isBound,\n  screens,\n  toggleBinding\n}) => {\n  const groups = inputState[groupType]\n  let displayGroups = Object.keys(groups).map((groupName) => ({\n    name: groupName,\n    group: groups[groupName]\n  }))\n  if (filter.trim() !== '') {\n    displayGroups = displayGroups.filter(({ name }) =>\n      name.toLowerCase().includes(filter.trim().toLowerCase()))\n  }\n  return (\n    <div className=\"input-groups\">\n      {displayGroups.map(({ name, group }) => (\n        <div className=\"input-group\" key={name}>\n          <div className=\"input-group-name\">\n            <div className={`diode ${getDiodeClass(group.ping)}`} />\n            <label>{name}</label>\n            <div className=\"screen-binding-controls\">\n              {Object.keys(screens.screens).map((screenId, i) => (\n                <input\n                  key={`${name}-${screenId}`}\n                  title={`Screen ${i + 1}`}\n                  data-testid={`group-control-${name}:${i}`}\n                  type=\"checkbox\"\n                  checked={isBound(groupType, name, screenId)}\n                  onChange={() => toggleBinding(groupType, name, screenId)}\n                />\n              ))}\n            </div>\n          </div>\n          {Object.keys(groups[name].pairs).map((otherName) => (\n            <InputControls\n              key={inputState.inputs[groups[name].pairs[otherName]].name}\n              input={inputState.inputs[groups[name].pairs[otherName]]}\n              labelName={otherName}\n            />\n          ))}\n        </div>\n      ))}\n    </div>\n  )\n}\n\n/**\n * Show all input names & controls\n */\nconst InputManager: React.FC<InputManagerProps> = ({\n  inputs,\n  isBound,\n  screens,\n  toggleBinding\n}) => {\n  const [activeInputGroup, setActiveInputGroup] = useState<GroupTypes>('streams')\n  const [activeFilter, setActiveFilter] = useState('')\n  return (\n    <div className=\"input-manager\">\n      <div className=\"input-group-toggles\">\n        <div\n          className={`input-group-toggle ${activeInputGroup === 'streams' ? 'active': ''}`}\n          onClick={() => setActiveInputGroup('streams')}\n        >\n          Streams\n        </div>\n        <div\n          className={`input-group-toggle ${activeInputGroup === 'sources' ? 'active': ''}`}\n          onClick={() => setActiveInputGroup('sources')}\n        >\n          Sources\n        </div>\n      </div>\n      <div className=\"input-filter\">\n        <input\n          type=\"text\"\n          value={activeFilter}\n          onChange={(e) => setActiveFilter(e.target.value)}\n          placeholder=\"Filter...\"\n        />\n      </div>\n      <InputGroups\n        filter={activeFilter}\n        groupType={activeInputGroup}\n        inputState={inputs}\n        isBound={isBound}\n        screens={screens}\n        toggleBinding={toggleBinding}\n      />\n    </div>\n  )\n}\n\n/**\n * Creates handler functions from app state\n */\nconst MappedInputManager: React.FC<MappedInputManagerProps> = ({ dispatch, state }) => {\n  const { bindings, inputs, screens } = state\n  // Create helper function to determine if group is bound\n  const isBound = useMemo(() => (\n    (groupType: GroupTypes, groupName: string, screenId: string): boolean => (\n      !!bindings[groupType][groupName] && !!bindings[groupType][groupName][screenId]\n    )\n  ), [bindings])\n\n  // Create function to update app state & notify server on group binding change\n  const toggleBinding = useMemo(() => (\n    (groupType: GroupTypes, groupName: string, screenId: string): void => {\n      switch (groupType) {\n        case 'streams': {\n          if (isBound(groupType, groupName, screenId)) {\n            dispatch({\n              type: BindingActions.UNBIND_STREAM_FROM_SCREEN,\n              stream: groupName, screenId\n            })\n          } else {\n            dispatch({\n              type: BindingActions.BIND_STREAM_TO_SCREEN,\n              stream: groupName, screenId\n            })\n          }\n          break\n        }\n        case 'sources': {\n          if (isBound(groupType, groupName, screenId)) {\n            dispatch({\n              type: BindingActions.UNBIND_SOURCE_FROM_SCREEN,\n              source: groupName, screenId\n            })\n          } else {\n            dispatch({\n              type: BindingActions.BIND_SOURCE_TO_SCREEN,\n              source: groupName, screenId\n            })\n          }\n          break\n        }\n      }\n    }\n  ), [dispatch, isBound])\n  return InputManager({ inputs, isBound, screens, toggleBinding })\n}\n\n/**\n * Connects component to app contexts\n */\nconst ConnectedInputManager: React.FC = () => {\n  const dispatch: Dispatch<ActionTypes> | null = useContext(DispatchContext)\n  const state: State | null = useContext(StateContext)\n  if (!dispatch || !state) {\n    return null\n  }\n  return MappedInputManager({ dispatch, state })\n}\n\nexport default ConnectedInputManager\n","import produce from 'immer'\n\nimport { BindingActions, BindingState, BindingActionTypes } from './types'\nimport { InputActions, InputState } from '../inputs/types'\nimport { ScreenActions } from '../screens/types'\n\nexport const initialBindingState: BindingState = {\n  inputs: {},\n  screens: {},\n  sources: {},\n  streams: {},\n}\n\n/**\n * Helper method to update state when an input is bound\n */\nconst bindInputToScreen = (\n  bindings: BindingState,\n  inputName: string,\n  screenId: string\n) => {\n  if (!bindings.inputs[inputName]) {\n    bindings.inputs[inputName] = {}\n  }\n  if (!bindings.screens[screenId]) {\n    bindings.screens[screenId] = {\n      inputs: {},\n      streams: {},\n      sources: {},\n    }\n  }\n  bindings.inputs[inputName][screenId] = true\n  bindings.screens[screenId].inputs[inputName] = true\n}\n\n/**\n * Helper method to update state when an input is unbound\n */\nconst unbindInputFromScreen = (\n  bindings: BindingState,\n  inputName: string,\n  screenId: string\n) => {\n  const { inputs, screens } = bindings\n  if (inputs[inputName]) {\n    delete inputs[inputName][screenId]\n  }\n  if (screens[screenId]) {\n    delete screens[screenId].inputs[inputName]\n  }\n}\n\n/**\n * Helper method to bind stream to screen if all stream inputs are bound\n */\nconst checkStreamBinding = (\n  state: BindingState,\n  inputs: InputState,\n  source: string,\n  stream: string,\n  screenId: string,\n) => {\n  const allStreamInputsBound = Object.keys(inputs.streams[stream].pairs).map((source) => (\n    inputs.streams[stream].pairs[source]\n  )).every((inputName) => (state.inputs[inputName] || {})[screenId])\n  if (allStreamInputsBound) {\n    if (!state.streams[stream]) {\n      state.streams[stream] = {}\n    }\n    state.streams[stream][screenId] = true\n  }\n}\n\n/**\n * Helper method to bind source to screen if all source inputs are bound\n */\nconst checkSourceBinding = (\n  state: BindingState,\n  inputs: InputState,\n  source: string,\n  stream: string,\n  screenId: string,\n) => {\n  const allSourceInputsBound = Object.keys(inputs.sources[source].pairs).map((stream) => (\n    inputs.sources[source].pairs[stream]\n  )).every((inputName) => (state.inputs[inputName] || {})[screenId])\n  if (allSourceInputsBound) {\n    if (!state.sources[source]) {\n      state.sources[source] = {}\n    }\n    state.sources[source][screenId] = true\n  }\n}\n\n/**\n * Manages application state for screen/input bindings\n */\nexport const BindingReducer = produce((\n  state: BindingState,\n  inputs: InputState,\n  action: BindingActionTypes\n) => {\n  switch (action.type) {\n\n    // Start displaying input messages on a screen\n    case BindingActions.BIND_INPUT_TO_SCREEN: {\n      const { inputName, screenId, source, stream } = action\n      bindInputToScreen(state, inputName, screenId)\n      checkStreamBinding(state, inputs, source, stream, screenId)\n      checkSourceBinding(state, inputs, source, stream, screenId)\n      break\n    }\n\n    // Stop displaying input messages on a screen\n    case BindingActions.UNBIND_INPUT_FROM_SCREEN: {\n      const { inputName, screenId, source, stream } = action\n      unbindInputFromScreen(state, inputName, screenId)\n      if (state.streams[stream]) {\n        delete state.streams[stream][screenId]\n      }\n      if (state.sources[source]) {\n        delete state.sources[source][screenId]\n      }\n      break\n    }\n\n    // Start display messages for all stream inputs on a screen\n    case BindingActions.BIND_STREAM_TO_SCREEN: {\n      const { stream, screenId } = action\n      const { pairs } = inputs.streams[stream]\n      Object.keys(pairs).forEach((source) => {\n        bindInputToScreen(state, pairs[source], screenId)\n        checkSourceBinding(state, inputs, source, stream, screenId)\n      })\n      if (!state.streams[stream]) {\n        state.streams[stream] = {}\n      }\n      state.streams[stream][screenId] = true\n      break\n    }\n\n    // Stop displaying messages for all stream inputs on a screen\n    case BindingActions.UNBIND_STREAM_FROM_SCREEN: {\n      const { stream, screenId } = action\n      const { pairs } = inputs.streams[stream]\n      Object.keys(pairs).forEach((source) => {\n        unbindInputFromScreen(state, pairs[source], screenId)\n        if (state.sources[source]) {\n          delete state.sources[source][screenId]\n        }\n      })\n      if (state.streams[stream]) {\n        delete state.streams[stream][screenId]\n      }\n      break\n    }\n\n    // Start display messages for all source inputs on a screen\n    case BindingActions.BIND_SOURCE_TO_SCREEN: {\n      const { source, screenId } = action\n      const { pairs } = inputs.sources[source]\n      Object.keys(pairs).forEach((stream) => {\n        bindInputToScreen(state, pairs[stream], screenId)\n        checkStreamBinding(state, inputs, source, stream, screenId)\n      })\n      if (!state.sources[source]) {\n        state.sources[source] = {}\n      }\n      state.sources[source][screenId] = true\n      break\n    }\n\n    // Stop displaying messages for all source inputs on a screen\n    case BindingActions.UNBIND_SOURCE_FROM_SCREEN: {\n      const { source, screenId } = action\n      const { pairs } = inputs.sources[source]\n      Object.keys(pairs).forEach((stream) => {\n        unbindInputFromScreen(state, pairs[stream], screenId)\n        if (state.streams[stream]) {\n          delete state.streams[stream][screenId]\n        }\n      })\n      if (state.sources[source]) {\n        delete state.sources[source][screenId]\n      }\n      break\n    }\n\n    // Clean up bindings when a screen is removed\n    case ScreenActions.REMOVE_SCREEN: {\n      const { screenId } = action\n      const screenBindings = state.screens[screenId] || {}\n      // Clean up input bindings\n      Object.keys(screenBindings.inputs || {}).forEach((inputName) => {\n        if (state.inputs[inputName]) {\n          delete state.inputs[inputName][screenId]\n        }\n      })\n      // Clean up stream bindings\n      Object.keys(screenBindings.streams || {}).forEach((stream) => {\n        if (state.streams[stream]) {\n          delete state.streams[stream][screenId]\n        }\n      })\n      // Clean up source bindings\n      Object.keys(screenBindings.sources || {}).forEach((source) => {\n        if (state.sources[source]) {\n          delete state.sources[source][screenId]\n        }\n      })\n      delete state.screens[screenId]\n      break\n    }\n\n    // Delete associated stream & source screen bindings when a new input arrives\n    case InputActions.ENSURE_INPUT: {\n      const { inputName, stream, source } = action\n      if (state.sources[source] && !inputs.inputs[inputName]) {\n        Object.keys(state.sources[source]).forEach((screenId) => {\n          delete state.sources[source][screenId]\n        })\n      }\n      if (state.streams[stream] && !inputs.inputs[inputName]) {\n        Object.keys(state.streams[stream]).forEach((screenId) => {\n          delete state.streams[stream][screenId]\n        })\n      }\n      break\n    }\n  }\n})\n\nexport default BindingReducer\n","import produce from 'immer'\n\nimport { InputActions, InputState, InputActionTypes } from './types'\n\nexport const initialInputState: InputState = {\n  inputs: {},\n  streams: {},\n  sources: {},\n}\n\n/**\n * Manages application state for message inputs\n */\nexport const InputReducer = produce((\n  state: InputState,\n  action: InputActionTypes\n) => {\n  const { inputs, streams, sources } = state\n  switch (action.type) {\n    // Server sent a new message\n    case InputActions.PING: {\n      const { inputName, stream, source } = action\n      const pingTime = new Date().getTime()\n      inputs[inputName].ping = pingTime\n      streams[stream].ping = pingTime\n      sources[source].ping = pingTime\n      break\n    }\n\n    // Initialize state for the provided input, if necessary\n    case InputActions.ENSURE_INPUT: {\n      const { inputName, stream, source } = action\n      if (!inputs[inputName]) {\n        inputs[inputName] = {\n          name: inputName,\n          ping: null,\n          stream,\n          source,\n        }\n        if (!streams[stream]) {\n          streams[stream] = {\n            ping: null,\n            pairs: {},\n          }\n        }\n        if (!sources[source]) {\n          sources[source] = {\n            ping: null,\n            pairs: {},\n          }\n        }\n        streams[stream].pairs[source] = inputName\n        sources[source].pairs[stream] = inputName\n      }\n      break\n    }\n    // Remove an input from state\n    case InputActions.REMOVE_INPUT: {\n      const { inputName, stream, source } = action\n      delete streams[stream].pairs[source]\n      delete sources[source].pairs[stream]\n      delete inputs[inputName]\n      break\n    }\n  }\n})\n\nexport default InputReducer\n\n","export const MessageActions = {\n  ADD_MESSAGE: 'ADD_MESSAGE' as 'ADD_MESSAGE',\n  CLEAR_MESSAGES: 'CLEAR_MESSAGES' as 'CLEAR_MESSAGES',\n}\n\nexport type MessageState = {\n  screens: { [screenId: string]: Array<string> },\n}\n\nexport type AddMessageAction = {\n  type: typeof MessageActions.ADD_MESSAGE,\n  inputName: string,\n  msg: string,\n}\n\nexport type ClearMessagesAction = {\n  type: typeof MessageActions.CLEAR_MESSAGES,\n  screenId: string,\n}\n\nexport type MessageActionTypes = AddMessageAction | ClearMessagesAction\n","import { MessageActions, MessageState, MessageActionTypes } from './types'\n\nimport { BindingState } from '../bindings/types'\n\nexport const initialMessageState: MessageState = {\n  screens: {},\n}\n\nconst MAX_MESSAGES = 10000\n\n/**\n * Manages application state for messages sent from the server\n */\nexport const MessageReducer = (\n  state: MessageState,\n  bindings: BindingState,\n  action: MessageActionTypes\n): MessageState => {\n  const { screens } = state\n  switch (action.type) {\n    // A new message has been sent from the server\n    case MessageActions.ADD_MESSAGE: {\n      const { inputName, msg } = action\n      const updatedScreens = { ...screens }\n      const screenBindings = bindings.inputs[inputName] || {}\n      Object.keys(screenBindings).forEach((screenId) => {\n        if (screenBindings[screenId]) {\n          const [stream, source] = inputName.split('|')\n          const message = `[${stream}] [${source}] - ${msg}`\n          let updatedMessages = (screens[screenId] || []).concat([message])\n          // Avoid slicing the array on every single update, slice() is expensive.\n          // Allow array to grow beyond the limit by a percentage, then slice.\n          if (updatedMessages.length > MAX_MESSAGES + Math.floor(MAX_MESSAGES * 0.02)) {\n            updatedMessages = updatedMessages.slice(-MAX_MESSAGES)\n          }\n          updatedScreens[screenId] = updatedMessages\n        }\n      })\n      return { screens: updatedScreens }\n    }\n    // Remove all messages from screen\n    case MessageActions.CLEAR_MESSAGES: {\n      return {\n        screens: {\n          ...screens,\n          [action.screenId]: [],\n        },\n      }\n    }\n    default:\n      return state\n  }\n}\n\nexport default MessageReducer\n","import { Dispatch } from 'react'\nimport socketIO from 'socket.io-client'\nimport { InputActions } from '../reducers/inputs/types'\nimport { MessageActions } from '../reducers/messages/types'\nimport { ActionTypes } from '../reducers/types'\n\nimport { MessageEvent, PingEvent, RegistrationEvent } from './types'\n\n/**\n * Creates a new socket.io connection to the server\n */\nexport const createSocket = (): SocketIOClient.Socket =>\n  socketIO()\n\n/**\n * Receives a new input event and adds it to relevant state\n */\nexport const registerNewInput = (\n  socket: SocketIOClient.Socket,\n  dispatch: Dispatch<ActionTypes>\n): void => {\n  socket.on('+input', (input: RegistrationEvent) => {\n    const { inputName, stream, source } = input\n    dispatch({ type: InputActions.ENSURE_INPUT, inputName, stream, source })\n  })\n}\n\nexport const unregisterNewInput = (socket: SocketIOClient.Socket): void => {\n  socket.off('+input')\n}\n\n/**\n * Receives a remove input event and removes it from relevant state\n */\nexport const registerRemoveInput = (\n  socket: SocketIOClient.Socket,\n  dispatch: Dispatch<ActionTypes>\n): void => {\n  socket.on('-input', (input: RegistrationEvent) => {\n    const { inputName, stream, source } = input\n    dispatch({ type: InputActions.REMOVE_INPUT, inputName, stream, source })\n  })\n}\n\nexport const unregisterRemoveInput = (socket: SocketIOClient.Socket): void => {\n  socket.off('-input')\n}\n\n/**\n * Receives a ping event and updates input state\n */\nexport const registerPing = (\n  socket: SocketIOClient.Socket,\n  dispatch: Dispatch<ActionTypes>\n): void => {\n  socket.on('+ping', (input: PingEvent) => {\n    const { inputName, stream, source } = input\n    dispatch({ type: InputActions.ENSURE_INPUT, inputName, stream, source })\n    dispatch({ type: InputActions.PING, inputName, stream, source })\n  })\n}\n\nexport const unregisterPing = (socket: SocketIOClient.Socket): void => {\n  socket.off('+ping')\n}\n\n/**\n * Receives a new message event and adds it to state\n */\nexport const registerNewMessage = (\n  socket: SocketIOClient.Socket,\n  dispatch: Dispatch<ActionTypes>\n): void => {\n  socket.on('+msg', (data: MessageEvent) => {\n    const { inputName, msg } = data\n    dispatch({ type: MessageActions.ADD_MESSAGE, inputName, msg })\n  })\n}\n\nexport const unregisterNewMessage = (socket: SocketIOClient.Socket): void => {\n  socket.off('+msg')\n}\n\nexport const sendBindInput = (\n  socket: SocketIOClient.Socket,\n  inputName: string,\n): void => {\n  socket.emit('+activate', inputName)\n}\n\nexport const sendUnbindInput = (\n  socket: SocketIOClient.Socket,\n  inputName: string,\n): void => {\n  socket.emit('-activate', inputName)\n}","import { BindingActions } from '../reducers/bindings/types'\nimport { ScreenActions } from '../reducers/screens/types'\nimport { ActionTypes, State } from '../reducers/types'\nimport { sendBindInput, sendUnbindInput } from '../socket'\n\n/**\n * Sends bind/unbind events to the server based on reducer actions\n * triggered by user actions\n */\nconst socketMiddleware = (\n  socket: SocketIOClient.Socket,\n  state: State,\n  action: ActionTypes\n): void => {\n  const { bindings, inputs } = state\n  switch(action.type) {\n    case BindingActions.BIND_STREAM_TO_SCREEN: {\n      // Tell server to start sending messages for all inputs in this stream.\n      // Server treats it as a noop if it's already sending input messages\n      Object.keys(inputs.streams[action.stream].pairs).forEach((source) => {\n        sendBindInput(socket, inputs.streams[action.stream].pairs[source])\n      })\n      break\n    }\n    case BindingActions.UNBIND_STREAM_FROM_SCREEN: {\n      // Tell server to stop sending messages for any of this stream's inputs\n      // that are no longer bound to a screen\n      Object.keys(inputs.streams[action.stream].pairs).forEach((source) => {\n        const inputName = inputs.streams[action.stream].pairs[source]\n        const boundToOtherScreens = Object.keys(bindings.inputs[inputName])\n          .some((screenId) => bindings.inputs[inputName][screenId])\n        if (!boundToOtherScreens) {\n          sendUnbindInput(socket, inputName)\n        }\n      })\n      break\n    }\n    case BindingActions.BIND_SOURCE_TO_SCREEN: {\n      // Tell server to start sending messages for all inputs from this source.\n      // Server treats it as a noop if it's already sending input messages\n      Object.keys(inputs.sources[action.source].pairs).forEach((stream) => {\n        sendBindInput(socket, inputs.sources[action.source].pairs[stream])\n      })\n      break\n    }\n    case BindingActions.UNBIND_SOURCE_FROM_SCREEN: {\n      // Tell server to stop sending messages for any of this sources's inputs\n      // that are no longer bound to a screen\n      Object.keys(inputs.sources[action.source].pairs).forEach((stream) => {\n        const inputName = inputs.sources[action.source].pairs[stream]\n        const boundToOtherScreens = Object.keys(bindings.inputs[inputName])\n          .some((screenId) => bindings.inputs[inputName][screenId])\n        if (!boundToOtherScreens) {\n          sendUnbindInput(socket, inputName)\n        }\n      })\n      break\n    }\n    case BindingActions.BIND_INPUT_TO_SCREEN: {\n      // Tell server to start sending messages for this input.\n      // Server treats it as a noop if it's already sending input messages\n      sendBindInput(socket, action.inputName)\n      break\n    }\n    case BindingActions.UNBIND_INPUT_FROM_SCREEN: {\n      // Tell server to stop sending messages for this input if it's not\n      // bound to any other screens\n      const boundToOtherScreens = Object.keys(bindings.inputs[action.inputName])\n        .some((screenId) => bindings.inputs[action.inputName][screenId])\n      if (!boundToOtherScreens) {\n        sendUnbindInput(socket, action.inputName)\n      }\n      break\n    }\n    case ScreenActions.REMOVE_SCREEN: {\n      // Tell server to stop sending messages for any of this screen's inputs\n      // if it's not bound to any other screens\n      if (!bindings.screens[action.screenId]) {\n        return\n      }\n      Object.keys(bindings.screens[action.screenId].inputs).forEach((inputName) => {\n        const boundToOtherScreens = Object.keys(bindings.inputs[inputName])\n          .some((screenId) => bindings.inputs[inputName][screenId])\n        if (!boundToOtherScreens) {\n          sendUnbindInput(socket, inputName)\n        }\n      })\n      break\n    }\n  }\n}\n\nexport default socketMiddleware\n","import { BindingActions } from '../reducers/bindings/types'\nimport { ScreenActions } from '../reducers/screens/types'\nimport { ActionTypes, State } from '../reducers/types'\n\nexport type UrlBindingStateType = {\n  [screenId: string]: Array<string>\n}\n\n/**\n * Update URL hash with binding state\n */\nconst urlMiddleware = (\n  socket: SocketIOClient.Socket,\n  state: State,\n  action: ActionTypes\n): void => {\n  const { bindings } = state\n  switch(action.type) {\n    case BindingActions.BIND_STREAM_TO_SCREEN:\n    case BindingActions.UNBIND_STREAM_FROM_SCREEN:\n    case BindingActions.BIND_SOURCE_TO_SCREEN:\n    case BindingActions.UNBIND_SOURCE_FROM_SCREEN:\n    case BindingActions.BIND_INPUT_TO_SCREEN:\n    case BindingActions.UNBIND_INPUT_FROM_SCREEN:\n    case ScreenActions.REMOVE_SCREEN: {\n      const urlBindingState: UrlBindingStateType = {}\n      Object.keys(bindings.screens).forEach((screenId) => {\n        urlBindingState[screenId] = Object.keys(bindings.screens[screenId].inputs)\n          .filter((inputName) => bindings.screens[screenId].inputs[inputName])\n      })\n      window.location.hash = JSON.stringify(urlBindingState)\n    }\n  }\n}\n\nexport default urlMiddleware\n","import produce from 'immer'\n\nimport { ScreenActions, ScreenState, ScreenActionTypes } from './types'\n\nexport const initialScreenState: ScreenState = {\n  screens: {},\n}\n\nfunction generateScreenId(): string {\n  return String(new Date().valueOf())\n}\n\n/**\n * Manages application state for screens\n */\nexport const ScreenReducer = produce((\n  state: ScreenState,\n  action: ScreenActionTypes\n) => {\n  const { screens } = state\n  switch (action.type) {\n    // Create a new screen\n    case ScreenActions.ADD_SCREEN: {\n      const screenId = action.screenId || generateScreenId()\n      screens[screenId] = {\n        id: screenId,\n        messages: [],\n      }\n      break\n    }\n    // Remove an existing screen\n    case ScreenActions.REMOVE_SCREEN: {\n      const { screenId } = action\n      if (screenId) {\n        delete screens[screenId]\n      }\n      break\n    }\n  }\n})\n\nexport default ScreenReducer\n","import BindingReducer, { initialBindingState } from './bindings'\nimport { BindingActionTypes } from './bindings/types'\nimport InputReducer, { initialInputState } from './inputs'\nimport MessageReducer, { initialMessageState } from './messages'\nimport { InputActionTypes } from './inputs/types'\nimport { MessageActionTypes } from './messages/types'\nimport socketMiddleware from '../middleware/socket'\nimport urlMiddleware from '../middleware/url'\nimport ScreenReducer, { initialScreenState } from './screens'\nimport { ScreenActionTypes } from './screens/types'\nimport { ActionTypes, State } from './types'\n\nexport const initializeState = (socket: SocketIOClient.Socket): State => ({\n  bindings: initialBindingState,\n  inputs: initialInputState,\n  messages: initialMessageState,\n  screens: initialScreenState,\n  socket,\n})\n\nexport const Reducer = (state: State, action: ActionTypes): State => {\n  const { bindings, inputs, messages, screens, socket } = state\n  const newState = {\n    bindings: BindingReducer(bindings, inputs, (action as BindingActionTypes)),\n    inputs: InputReducer(inputs, (action as InputActionTypes)),\n    messages: MessageReducer(messages, bindings, (action as MessageActionTypes)),\n    screens: ScreenReducer(screens, (action as ScreenActionTypes)),\n    socket,\n  }\n  socketMiddleware(socket, newState, action)\n  urlMiddleware(socket, newState, action)\n  return newState\n}\n\nexport default Reducer\n","import React, { Dispatch, useContext, useEffect, useMemo, useState } from 'react'\nimport { DebounceInput } from 'react-debounce-input'\n\nimport { DispatchContext, StateContext } from '../../contexts'\nimport { ActionTypes, State } from '../../reducers/types'\nimport { MessageActions, MessageState } from '../../reducers/messages/types'\nimport { ScreenActions, Screen as ScreenType, ScreenState } from '../../reducers/screens/types'\n\nimport './styles.scss'\n\ninterface ScreenManagerProps {\n  addScreen: () => void,\n  clearMessages: (screenId: string) => void,\n  messages: MessageState,\n  removeScreen: (screenId: string) => void,\n  screens: ScreenState,\n}\n\ninterface MappedScreenManagerProps {\n  dispatch: Dispatch<ActionTypes>,\n  state: State,\n}\n\ninterface ScreenProps {\n  clearMessages: (screenId: string) => void,\n  screen: ScreenType,\n  screenIndex: number,\n  messages: Array<string>,\n  removeScreen: (screenId: string) => void,\n}\n\ninterface ScreenMessageProps {\n  message: string,\n  messageFilter: string,\n}\n\n/**\n * Search a string for filter substring matches.\n * Returns a list of parts w/ highlight flag.\n */\nconst _parseMessageParts = (str: string, find: string) => {\n  const parts = []\n  let counter = 0\n  let lastMatchIndex = 0\n  const lowerStr = str.toLowerCase()\n  const lowerFind = find.toLowerCase()\n  while (counter < str.length) {\n    const end = counter + find.length\n    if (lowerStr.substring(counter, end) === lowerFind) {\n      parts.push({ highlight: false, text: str.slice(lastMatchIndex, counter)})\n      parts.push({ highlight: true, text: str.slice(counter, end)})\n      counter = end\n      lastMatchIndex = end\n    }\n    counter += 1\n  }\n  parts.push({ highlight: false, text: str.slice(lastMatchIndex, str.length)})\n  return parts\n}\n\n/**\n * Renders a single message\n */\nconst ScreenMessage: React.FC<ScreenMessageProps> = ({\n  message,\n  messageFilter\n}) => {\n  return (\n    <div>\n      {messageFilter && _parseMessageParts(message, messageFilter).map((part, i) =>\n        <span key={i} className={part.highlight ? 'highlight' : ''}>{part.text}</span>\n      )}\n      {!messageFilter && message}\n    </div>\n  )\n}\n\n/**\n * Renders a single screen\n */\nconst Screen: React.FC<ScreenProps> = ({\n  clearMessages,\n  messages,\n  removeScreen,\n  screen,\n  screenIndex\n}) => {\n  const [ messageFilter, setMessageFilter ] = useState('')\n  const [ validMessages, setValidMessages ] = useState(messages)\n  // Filter validMessages using messageFilter\n  useEffect(() => {\n    setValidMessages(\n      messages.filter((msg) =>\n        messageFilter === ''\n          ? true\n          : msg.toLowerCase().includes(messageFilter.toLowerCase()))\n    )\n  }, [messages, messageFilter])\n  return (\n    <>\n      <div className=\"screen-header\">\n        <div className=\"title\">\n          Screen {screenIndex + 1}\n        </div>\n        <div className=\"controls\">\n          <DebounceInput\n            minLength={2}\n            debounceTimeout={200}\n            placeholder=\"Filter\"\n            onChange={e => setMessageFilter(e.target.value)}\n          />\n          <button onClick={() => clearMessages(screen.id)}>\n            Clear\n          </button>\n          <button onClick={() => removeScreen(screen.id)}>\n            Close\n          </button>\n        </div>\n      </div>\n      <div className=\"screen\" data-testid={`screen-${screenIndex}`}>\n        <div className=\"screen-messages\">\n          {validMessages.map((message, i) => (\n            <ScreenMessage key={i} message={message} messageFilter={messageFilter} />\n          ))}\n        </div>\n      </div>\n    </>\n  )\n}\n\n/**\n * Render all screens & screen controls\n */\nconst ScreenManager: React.FC<ScreenManagerProps> = ({\n  addScreen,\n  clearMessages,\n  messages,\n  removeScreen,\n  screens\n}) => {\n  const screenIds = Object.keys(screens.screens)\n  return (\n    <div className=\"screens\">\n      {screenIds.map((screenId, i) => (\n        <Screen\n          key={screenId}\n          clearMessages={clearMessages}\n          removeScreen={removeScreen}\n          screen={screens.screens[screenId]}\n          screenIndex={i}\n          messages={messages.screens[screenId] || []}\n        />\n      ))}\n      <div className=\"screens-controls\">\n        {screenIds.length < 6 && (\n          <button\n            data-testid=\"add-screen-btn\"\n            className=\"add-screen-btn\"\n            onClick={addScreen}\n          >\n            &#65291; Add Screen\n          </button>\n        )}\n      </div>\n    </div>\n  )\n}\n\n/**\n * Creates handler functions from app state\n */\nconst MappedScreenManager: React.FC<MappedScreenManagerProps> = ({ dispatch, state }) => {\n  const { messages, screens } = state\n\n  // Create click handler functions to add/remove screens\n  const addScreen = useMemo(() => (\n    () => { dispatch({ type: ScreenActions.ADD_SCREEN }) }\n  ), [dispatch])\n\n  // Create click handler to remove a screen.\n  const removeScreen = useMemo(() => (\n    (screenId: string) => { dispatch({ type: ScreenActions.REMOVE_SCREEN, screenId }) }\n  ), [dispatch])\n\n  const clearMessages = useMemo(() => (\n    (screenId: string) => { dispatch({ type: MessageActions.CLEAR_MESSAGES, screenId }) }\n  ), [dispatch])\n\n  return ScreenManager({ addScreen, clearMessages, messages, removeScreen, screens })\n}\n\n/**\n * Connects component to app contexts\n */\nconst ConnectedScreenManager: React.FC = () => {\n  const state: State | null = useContext(StateContext)\n  const dispatch: Dispatch<ActionTypes> | null = useContext(DispatchContext)\n  if (!state || !dispatch) {\n    return null\n  }\n  return MappedScreenManager({ dispatch, state })\n}\n\nexport default ConnectedScreenManager\n","import React, { useEffect, useReducer } from 'react'\nimport initializeState from './initialize'\nimport { DispatchContext, StateContext } from '../../contexts'\nimport InputManager from '../inputs'\nimport reducer from '../../reducers'\nimport { State } from '../../reducers/types'\nimport ScreenManager from '../screens'\nimport {\n  registerNewInput,\n  registerNewMessage,\n  registerPing,\n  registerRemoveInput,\n} from '../../socket'\n\nimport './styles.scss'\n\ninterface AppProps {\n  initialState: State,\n  socket: SocketIOClient.Socket,\n}\n\n/**\n * App container component\n */\nconst App: React.FC<AppProps> = ({ initialState, socket }) => {\n  const [state, dispatch] = useReducer(reducer, initialState)\n\n  // Register socket listeners\n  useEffect(() => registerNewInput(socket, dispatch), [dispatch, socket])\n  useEffect(() => registerRemoveInput(socket, dispatch), [dispatch, socket])\n  useEffect(() => registerPing(socket, dispatch), [dispatch, socket])\n  useEffect(() => registerNewMessage(socket, dispatch), [dispatch, socket])\n\n  // Initialize screens & bindings from URL\n  useEffect(() => initializeState(dispatch, window.location.hash), [dispatch, socket])\n\n  return (\n    <DispatchContext.Provider value={dispatch}>\n      <StateContext.Provider value={state}>\n        <div className=\"app\">\n          <div className=\"left-column\">\n            {state && <InputManager />}\n          </div>\n          <div className=\"right-column\">\n            {state && <ScreenManager />}\n          </div>\n        </div>\n      </StateContext.Provider>\n    </DispatchContext.Provider>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './components/app'\nimport { initializeState } from './reducers'\nimport { createSocket } from './socket'\n\nimport './index.scss'\n\nconst Root: React.FC = () => {\n  const socket = createSocket()\n  const initialState = initializeState(socket)\n  return (\n    <App\n      socket={socket}\n      initialState={initialState}\n    />\n  )\n}\n\nReactDOM.render(<Root />, document.getElementById('root'))\n"],"sourceRoot":""}